// @ts-types="https://cdn.sheetjs.com/xlsx-latest/package/types/index.d.ts"
import * as XLSX from "XLSX";

import { IExporter } from "./IExporter.ts";
import { IExportOption } from "./_types/IExportOption.ts";
import { IExportResult } from "./_types/IExportResult.ts";
import { capitalizeFirstLetter, readWorkbook, validateValue } from "../../lib.ts";
import { validateName } from "./ExportUtil.ts";
import { TColumnType } from "./_types/TColumnType.ts";
import { cliName, refRegExp } from "../../env.ts";

enum EStructureType {
    Class,
    Struct,
}

export class CSharpExporter implements IExporter {
    #option: IExportOption;
    #filePath: string;
    #workbook?: ReturnType<(typeof XLSX)["readFile"]>;

    #outFileHeader: string = `///******************************************************************************
///     Generated by ${cliName} at ${new Date().toLocaleString()} ðŸ˜„ðŸ˜„ðŸ˜„
///******************************************************************************

using System;

`;

    #codePlaceholder: string = "#replace_code_here#";
    #namePlaceholder: string = "#replace_sheetName_here#";
    #structType: EStructureType = EStructureType.Class;

    constructor(option: IExportOption, filePath: string) {
        this.#option = option;
        this.#filePath = filePath;
    }

    public process(): Array<IExportResult> {
        const result: Array<IExportResult> = [];
        this.#workbook = readWorkbook(this.#filePath);

        for (let i = 0; i < this.#workbook.SheetNames.length; ++i) {
            const sheetName = this.#workbook.SheetNames[i];
            if (!validateName(sheetName)) continue;

            // console.log("sheet: " + sheetName);
            const sheetResult = this.#processSheet(sheetName);
            if (sheetResult !== undefined) {
                result.push(sheetResult);
            }
        }
        // console.log(result)
        return result;
    }

    #processSheet(sheetName: string): IExportResult | undefined {
        const code = this.#generateCode(sheetName);
        if (code === undefined) {
            return undefined;
        }

        let content = `${this.#outFileHeader}`;
        content += this.#option.csharpNs !== undefined ? `namespace ${this.#option.csharpNs} \n{\n${this.#codePlaceholder}\n}` : `${this.#codePlaceholder}`;
        content = content.replaceAll(this.#codePlaceholder, code);

        const structureName = this.#getStructureName(sheetName);
        return { content, fileName: `${structureName}.${this.#option.format}` };
    }

    #generateCode(sheetName: string): string | undefined {
        // console.log(sheetName);
        const sheet = this.#workbook!.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json<Array<unknown>>(sheet, {
            header: 1,
            blankrows: this.#option.keepBlankRows,
            defval: null,
        });

        // empty sheet
        if (rows.length === 0) {
            return undefined;
        }

        let keyRow = rows[this.#option.keyRow - 1] as Array<string>;
        let typeRow = rows[this.#option.typeRow - 1] as Array<TColumnType>;
        let descRow = rows[this.#option.descRow - 1] as Array<string>;

        // todo å¯¼å‡ºå¤šä½™çš„åˆ—ï¼Ÿï¼Ÿï¼Ÿ
        typeRow = typeRow.filter(Boolean);
        keyRow = keyRow.filter(Boolean);
        // descRow = descRow.filter(Boolean);



        let code = ``;
        for (let i = 0; i < typeRow.length; ++i) {
            const type = typeRow[i];

            let codeOutput: string | undefined = "";
            // todo @!sheetNameåº”è¯¥å¤„ç†ï¼Œ@sheetNameä¸åº”è¯¥å¤„ç†
            const matchResult = type.match(refRegExp);
            // console.log(matchResult);
            if (matchResult !== null && matchResult[1] !== undefined) {
                const refSheetName = matchResult[2];
                // console.log(`refSheetName: ${refSheetName}`);
                codeOutput = this.#generateCode("!" + refSheetName);
                if (codeOutput !== undefined) {
                    code += `${codeOutput}\n\n`;
                }

                continue;
            }

            if (type === "enum") {
                // enum
                codeOutput = this.#generateEnumCode(i, keyRow[i], rows);
                // console.log(codeOutput);
                if (codeOutput !== undefined) {
                    code += `${codeOutput}\n\n`;
                }

                continue;
            }
        }

        // todo åšæˆå‘½åè¡Œå‚æ•°ï¼Ÿï¼Ÿï¼Ÿ
        code += `\t[Serializable]\n`;
        code += `\tpublic ${this.#getStructureType()} ${this.#namePlaceholder} \n\t{`;
        for (let len = keyRow.length - 1; len >= 0; --len) {
            const key = keyRow[len];
            if (!validateName(key)) {
                continue;
            }

            const type = typeRow[len];
            const desc = descRow[len];

            if (validateValue(desc)) {
                // comment
                code += `
\t\t/// <summary>
${String(desc)
    .split("\n")
    .map((line) => `\t\t/// ${line}`)
    .join("\n")}
\t\t/// </summary>`;
            }

            // field
            code += `\n\t\tpublic ${this.#getCSharpType(type, key)} ${key};\n`;
        }

        code += "\t}";

        const structureName = this.#getStructureName(sheetName);
        code = code.replaceAll(this.#namePlaceholder, structureName);

        return code;
    }

    #generateEnumCode(colNum: number, key: string, rows: Array<Array<unknown>>): string | undefined {
        const enums = new Set<string>();
        for (let i = this.#option.ignoreRows; i < rows.length; ++i) {
            const row = rows[i];
            const col = row[colNum];
            enums.add(String(col));
        }

        const content = Array.from(enums)
            .map((item) => `\t\t${item}`)
            .join(",\n");

        let code = "";
        code += `\t[Serializable]\n`;
        code += `\tpublic enum ${this.#getEnumName(key)} \n\t{\n${content}\n\t}`;

        return code;
    }

    #getStructureName(sheetName: string) {
        let sheetOutputName = this.#getSheetOutputName(sheetName);
        if (this.#option.csharpSuffix !== undefined && this.#option.csharpSuffix !== "") {
            sheetOutputName += this.#option.csharpSuffix;
        }

        return capitalizeFirstLetter(sheetOutputName);
    }

    #getSheetOutputName(sheetName: string) {
        // if (this.#workbook!.SheetNames[0] === sheetName) {
        //     return getFilenameNoExtension(this.#filePath);
        // }

        if (sheetName[0] === "!") {
            return sheetName.substring(1);
        }

        return sheetName;
    }

    #getCSharpType(type: TColumnType, key: string) {
        const matchResult = type.match(refRegExp);

        // console.log(matchResult);
        if (matchResult !== null) {
            const targetTypeName = this.#getStructureName(matchResult[2]);

            return matchResult[3] === undefined || matchResult[4] !== undefined ? `${targetTypeName}[]` : targetTypeName;
        }

        switch (type as TColumnType) {
            case "int":
            case "float":
            case "int[]":
            case "bool":
            case "string":
            case "float[]":
                return type;
            case "[]":
            case "string[]":
                return "string[]";
            case "enum":
                return this.#getEnumName(key);
            default:
                return "string";
        }
    }

    #getEnumName(key: string) {
        return `E${capitalizeFirstLetter(key)}`;
    }

    #getStructureType() {
        switch (this.#structType) {
            case EStructureType.Class:
                return "class";
            case EStructureType.Struct:
                return "struct";
        }

        return "";
    }
}
