import {
  Command,
  EnumType,
} from "@cliffy/command";
import * as path from "@std/path";
import { ensureDirSync } from "@std/fs";

// @deno-types="https://cdn.sheetjs.com/xlsx-latest/package/types/index.d.ts"
import * as XLSX from "https://cdn.sheetjs.com/xlsx-latest/package/xlsx.mjs";

import { readWorkbook, resolveInput, snakeToPascal } from "../../lib.ts";

type ColumnType =
  | "int"
  | "float"
  | "bool"
  | "string"
  | "[]"
  | "string[]"
  | "int[]"
  | "float[]";

interface Options {
  format: "json" | "cs";
  outDir?: string;
  headerRow: number;
  csharpNs?: string;
  csharpSuffix?: string;
  keepCase?: boolean;
}

class ExportCommand {
  #formatType;
  constructor() {
    this.#formatType = new EnumType(["json", "cs"]);
  }

  #validateOptions(options: Options) {
    if (options.headerRow < 1) {
      throw new RangeError("--header-row must be at latest 1");
    }
  }

  #tasks: Array<Promise<void>> = [];
  #pushTask(task: Promise<void>) {
    this.#tasks.push(task);
  }
  async #waitTasks() {
    await Promise.all(this.#tasks);
    this.#tasks = [];
  }

  #opts: Options = undefined as any;

  register(command: Command) {
    command
      .command("export", "Export sheet from ods or xlsx to json, cs")
      .type("format", this.#formatType)
      .option("-f, --format <value:format>", "Output format.", {
        default: "json" as const,
      })
      .option(
        "--csharp-ns <ns:string>",
        "Specify namespace of output csharp file.",
      )
      .option(
        "--csharp-suffix <suffix:string>",
        "Output class/file suffix, Default: Config, eg. Job -> JobConfig",
        { default: "Config" },
      )
      .option(
        "--keep-case",
        "snake_case will be converted to PascalCase by default. use this option prevent default action.",
      )
      .option(
        "-o, --out-dir <dir:string>",
        "Output path. By default file will be converted in-place.",
      )
      .option("--header-row <header:number>", "Row point to header.", {
        // =================================================
        // ÈªòËÆ§Á¨¨‰∏ÄË°å‰∏∫headerÔºåÂ¶ÇÊûúÂØºÂá∫‰∏∫jsonÔºåheaderË°åÁöÑÊØèÂàóÂ∞ÜÁî®‰∫éjsonÁöÑkey
        // Â¶ÇÊûúÂØºÂá∫‰∏∫xmlÔºåheaderË°åÁöÑÊØèÂàóÂ∞ÜÁî®‰∫éËäÇÁÇπÁöÑÂêçÁß∞
        // =================================================
        default: 1,
      })
      .arguments("[input:string] [...restArgs:string]")
      .action(async (options, ...args) => {
        // console.log(options);

        this.#validateOptions(options);

        this.#opts = options;

        switch (options.format) {
          case "json":
            await this.#exportToJson(args as string[]);
            break;
          case "cs":
            await this.#exportToCSharp(args as string[]);
            break;
        }
      });
  }

  // ÂØºÂá∫csharpÊñá‰ª∂
  async #exportToCSharp(inputArr: string[]) {
    const filePathArr = await resolveInput(inputArr);
    for (let i = 0; i < filePathArr.length; ++i) {
      const filePath = filePathArr[i];

      console.log("processing file: " + filePath);

      const workbook = readWorkbook(filePath);

      let outFrameStr = `
///******************************************************************************
///     Generated by hahaconvert at ${new Date().toLocaleString()} üòÑüòÑüòÑ
///******************************************************************************
`;
      const codePlaceholder = "#$@#";
      const namePlaceholder = "#sheetName#";
      if (this.#opts.csharpNs != undefined) {
        outFrameStr +=
          `namespace ${this.#opts.csharpNs} {\n${codePlaceholder}\n}`;
      } else {
        outFrameStr += `\n${codePlaceholder}`;
      }

      const sheetOutObj: Record<string, string> = {};
      for (let j = 0; j < workbook.SheetNames.length; ++j) {
        const sheetName = workbook.SheetNames[j];

        if (!this.#validate(sheetName)) continue;
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, {
          header: 1,
          blankrows: false,
          defval: null,
        });

        // empty sheet
        if (rows.length === 0) continue;

        console.log("sheet: " + sheetName);
        const [headerRow, descRow] = rows.splice(
          this.#opts.headerRow - 1,
          2,
        ) as string[][];

        let sheetOut = `\tpublic class ${namePlaceholder} {\n`;
        for (let m = 0; m < headerRow.length; ++m) {
          const headerCell = headerRow[m];

          // comment
          sheetOut += `
\t\t/// <summary>
\t\t/// ${descRow[m]}
\t\t/// </summary>
`;

          // field
          sheetOut += `\t\tpublic ${this.#getColumnCSharpType(
            headerCell,
          )
            } ${this.#getColumnKey(headerCell)};\n`;
        }

        // ShallowCopy
        sheetOut += `\n\t\tpublic ${namePlaceholder} ShallowCopy()
\t\t{
\t\t\treturn (${namePlaceholder})MemberwiseClone();
\t\t}\n`

        sheetOut += "\n\t}";
        sheetOutObj[j] = sheetOut;
      }

      // Â¶ÇÊûúÂè™ÂØºÂá∫‰∫Ü‰∏Ä‰∏™sheet, ÂàôÂØºÂá∫Êñá‰ª∂‰∏∫Êñá‰ª∂ÂêçÁß∞
      const keys = Object.keys(sheetOutObj);

      if (keys.length < 1) continue;
      if (keys.length == 1) {
        const className = this.#getOutFileName(filePath) +
          this.#opts.csharpSuffix;

        let sheetOutStr = sheetOutObj[keys[0]];
        sheetOutStr = sheetOutStr.replaceAll(namePlaceholder, className);
        sheetOutStr = outFrameStr.replaceAll(codePlaceholder, sheetOutStr);

        this.#pushTask(
          this.#writeToFile(this.#getOutFilePath(filePath), sheetOutStr),
        );
      } else {
        for (let n = 0; n < keys.length; ++n) {
          const className = workbook.SheetNames[Number(keys[n])] +
            this.#opts.csharpSuffix;

          let sheetOutStr = sheetOutObj[keys[n]];
          sheetOutStr.replaceAll(namePlaceholder, className);
          sheetOutStr = outFrameStr.replaceAll(codePlaceholder, sheetOutStr);

          this.#pushTask(
            this.#writeToFile(this.#getOutFilePath(filePath), sheetOutStr),
          );
        }
      }
    }

    await this.#waitTasks();
  }

  #getColumnCSharpType(headerCell: string) {
    const type = this.#getColumnType(headerCell);

    switch (type as ColumnType) {
      case "int":
      case "bool":
      case "float":
      case "string":
      case "int[]":
      case "float[]":
        return type;
      case "[]":
        return "string[]";
      default:
        return "string";
    }
  }

  // ÂØºÂá∫jsonÊñá‰ª∂
  async #exportToJson(inputArr: string[]) {
    const filePathArr = await resolveInput(inputArr);

    for (let i = 0; i < filePathArr.length; ++i) {
      const filePath = filePathArr[i];
      console.log("processing file: " + filePath);

      const workbook = readWorkbook(filePath);

      const out: Record<
        string,
        // sheet
        Array<Record<string, unknown>>
      > = {};

      for (let j = 0; j < workbook.SheetNames.length; ++j) {
        const sheetName = workbook.SheetNames[j];
        if (!this.#validate(sheetName)) continue;

        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, {
          header: 1,
          blankrows: false,
          defval: null,
        });

        // empty sheet
        if (rows.length === 0) continue;

        console.log("sheet: " + sheetName);
        const headerRow = rows.splice(
          this.#opts.headerRow - 1,
          2,
        )[1] as string[];

        const sheetRows: Array<Record<string, unknown>> = [];

        for (let m = 0; m < rows.length; ++m) {
          const row = rows[m] as unknown[];
          const rowJson: Record<string, unknown> = {};

          for (let n = 0; n < row.length; ++n) {
            const cellValue = row[n];
            const headerCell = headerRow[n];
            if (!this.#validate(headerCell)) continue;
            rowJson[this.#getColumnKey(headerCell)] = this.#convertColumnType(
              cellValue,
              headerCell,
            );
          }

          sheetRows.push(rowJson);
        }

        out[sheetName] = sheetRows;
      }

      let outObj: object = out;
      if (Object.keys(outObj).length === 1) {
        outObj = Object.values(outObj)[0];
      }

      this.#pushTask(
        this.#writeToFile(
          this.#getOutFilePath(filePath),
          JSON.stringify(outObj),
        ),
      );

      console.log("process finished.");
    }

    await this.#waitTasks();
  }

  async #writeToFile(file_p: string, content: string) {
    const file = await Deno.open(file_p, {
      write: true,
      truncate: true,
      create: true,
    });
    await file.write(new TextEncoder().encode(content));
  }

  #getOutFileName(filePath: string) {
    const fileName = path.basename(filePath);

    const outFileName = fileName.substring(
      0,
      fileName.indexOf(path.extname(fileName)),
    );
    return outFileName;
  }

  #getOutFilePath(file_p: string) {
    const outFileName = this.#getOutFileName(file_p);

    let fullOutFileName = outFileName;
    switch (this.#opts.format) {
      case "cs":
        fullOutFileName += this.#opts.csharpSuffix + "." + this.#opts.format;
        break;
      case "json":
      default:
        fullOutFileName += "." + this.#opts.format;
    }

    if (!this.#opts.outDir) {
      return path.join(path.dirname(file_p), fullOutFileName);
    }

    const outDir = path.resolve(this.#opts.outDir);
    ensureDirSync(outDir);
    return path.join(outDir, fullOutFileName);
  }

  #getColumnKey(headerCell: string): string {
    const key = headerCell.trim().split("#")[0];
    if (!this.#opts.keepCase) {
      return snakeToPascal(key);
    }
    return key;
  }
  #getColumnType(headerCell: string): ColumnType {
    return headerCell.trim().split("#")[1] as ColumnType;
  }

  #convertColumnType(cellValue: unknown, headerCell: string) {
    const columnType = this.#getColumnType(headerCell);

    switch (columnType) {
      case "int":
      case "float":
        if (cellValue === null || cellValue === undefined) { return cellValue; }
        return Number(cellValue);
      case "bool":
        return Boolean(cellValue);
      case "[]":
      case "string[]":
        return String(cellValue).split(",");
      case "int[]":
      case "float[]":
        return String(cellValue).split(",").map((val) => Number(val));
      case "string":
      default:
        if (cellValue === null || cellValue === undefined) { return ''; }
        return String(cellValue);
    }
  }

  // È™åËØÅÊï∞ÊçÆÊòØÂê¶ÈúÄË¶ÅË¢´ÂØºÂá∫ÔºåËøîÂõûtrueÂàôÈ™åËØÅÈÄöËøáÔºåfalseÈ™åËØÅÂ§±Ë¥•Âç≥Êï∞ÊçÆ‰∏çÂØºÂá∫
  #validate(name: string) {
    if (name === null || name === undefined) return false;
    console.log("validate: " + name + " type: " + typeof name);
    if (name.trim().startsWith("!")) return false;
    return true;
  }
}

const exportCommand = new ExportCommand();

export default exportCommand;
