import {
  Command,
  EnumType,
} from "https://deno.land/x/cliffy@v1.0.0-rc.3/command/mod.ts";
import * as path from "https://deno.land/std@0.196.0/path/mod.ts";
import { ensureDirSync } from "https://deno.land/std@0.196.0/fs/mod.ts";

// @deno-types="https://cdn.sheetjs.com/xlsx-latest/package/types/index.d.ts"
import * as XLSX from "https://cdn.sheetjs.com/xlsx-latest/package/xlsx.mjs";

import { readWorkbook, resolveInput } from "../../lib.ts";

type ColumnType =
  | "int"
  | "float"
  | "bool"
  | "string"
  | "[]"
  | "int[]"
  | "float[]";

interface Options {
  format: "json" | "cs";
  outDir?: string;
  headerRow: number;
  csharpNs?: string;
  csharpSuffix?: string;
}

class ExportCommand {
  #formatType;
  constructor() {
    this.#formatType = new EnumType(["json", "cs"]);
  }

  #validateOptions(options: Options) {
    if (options.headerRow < 1) {
      throw new RangeError("--header-row must be at latest 1");
    }
  }

  #tasks: Array<Promise<void>> = [];
  #pushTask(task: Promise<void>) {
    this.#tasks.push(task);
  }
  async #waitTasks() {
    await Promise.all(this.#tasks);
    this.#tasks = [];
  }

  register(command: Command) {
    command
      .command("export", "Export sheet from ods or xlsx to json, cs")
      .type("format", this.#formatType)
      .option("-f, --format <value:format>", "Output format.", {
        default: "json" as const,
      })
      .option(
        "--csharp-ns <ns:string>",
        "Specify namespace of output csharp file."
      )
      .option(
        "--csharp-suffix <suffix:string>",
        "Output class/file suffix, Default: Config, eg. Job -> JobConfig",
        { default: "Config" }
      )
      .option(
        "-o, --out-dir <dir:string>",
        "Output path. By default file will be converted in-place."
      )
      .option("--header-row <header:number>", "Row point to header.", {
        // =================================================
        // é»˜è®¤ç¬¬ä¸€è¡Œä¸ºheaderï¼Œå¦‚æœå¯¼å‡ºä¸ºjsonï¼Œheaderè¡Œçš„æ¯åˆ—å°†ç”¨äºjsonçš„key
        // å¦‚æœå¯¼å‡ºä¸ºxmlï¼Œheaderè¡Œçš„æ¯åˆ—å°†ç”¨äºèŠ‚ç‚¹çš„åç§°
        // =================================================
        default: 1,
      })
      .arguments("[input:string] [...restArgs:string]")
      .action(async (options, ...args) => {
        // console.log(options);
        this.#validateOptions(options);

        switch (options.format) {
          case "json":
            await this.#exportToJson(args as string[], options);
            break;
          case "cs":
            await this.#exportToCSharp(args as string[], options);
            break;
        }
      });
  }

  // å¯¼å‡ºcsharpæ–‡ä»¶
  async #exportToCSharp(inputArr: string[], options: Options) {
    const filePathArr = await resolveInput(inputArr);
    for (let i = 0; i < filePathArr.length; ++i) {
      const filePath = filePathArr[i];

      console.log("processing file: " + filePath);

      const workbook = readWorkbook(filePath);

      let outFrameStr = `
///******************************************************************************
///     Generated by hahaconvert at ${new Date().toLocaleString()} ğŸ˜„ğŸ˜„ğŸ˜„
///******************************************************************************
`;
      const codePlaceholder = "#$@#";
      const namePlaceholder = "#sheetName#";
      if (options.csharpNs != undefined) {
        outFrameStr += `namespace ${options.csharpNs} {\n${codePlaceholder}\n}`;
      } else {
        outFrameStr += `\n${codePlaceholder}`;
      }

      const sheetOutObj: Record<string, string> = {};
      for (let j = 0; j < workbook.SheetNames.length; ++j) {
        const sheetName = workbook.SheetNames[j];

        if (!this.#validate(sheetName)) continue;
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, {
          header: 1,
          blankrows: false,
          defval: null,
        });

        // empty sheet
        if (rows.length === 0) continue;

        console.log("sheet: " + sheetName);
        const [headerRow, descRow] = rows.splice(
          options.headerRow - 1,
          2
        ) as string[][];

        let sheetOut = `\tpublic class ${namePlaceholder} {\n`;
        for (let m = 0; m < headerRow.length; ++m) {
          const headerCell = headerRow[m];

          const valueArr = headerCell.split("#");

          // comment
          sheetOut += `
\t\t/// <summary>
\t\t/// ${descRow[m]}
\t\t/// </summary>
`;

          // field
          sheetOut += `\t\tpublic ${this.#getColumnCSharpType(valueArr[1])} ${
            valueArr[0]
          };\n`;
        }

        sheetOut += "\t}";
        sheetOutObj[j] = sheetOut;
      }

      // å¦‚æœåªå¯¼å‡ºäº†ä¸€ä¸ªsheet, åˆ™å¯¼å‡ºæ–‡ä»¶ä¸ºæ–‡ä»¶åç§°
      const keys = Object.keys(sheetOutObj);

      if (keys.length < 1) continue;
      if (keys.length == 1) {
        sheetOutObj[keys[0]] = sheetOutObj[keys[0]].replace(
          namePlaceholder,
          this.#getOutFileName(filePath) + options.csharpSuffix
        );
      } else {
        for (let n = 0; n < keys.length; ++n) {
          sheetOutObj[keys[n]].replace(
            namePlaceholder,
            workbook.SheetNames[Number(keys[n])] + options.csharpSuffix
          );
        }
      }

      for (let x = 0; x < keys.length; ++x) {
        const sheetOutStr = outFrameStr.replace(
          codePlaceholder,
          sheetOutObj[keys[x]]
        );

        this.#pushTask(
          this.#writeToFile(
            this.#getOutFilePath(filePath, options),
            sheetOutStr
          )
        );
      }
    }

    await this.#waitTasks();
  }

  #getColumnCSharpType(type: string) {
    switch (type as ColumnType) {
      case "int":
      case "bool":
      case "float":
      case "string":
      case "int[]":
      case "float[]":
        return type;
      case "[]":
        return "string[]";
      default:
        return "string";
    }
  }

  // å¯¼å‡ºjsonæ–‡ä»¶
  async #exportToJson(inputArr: string[], options: Options) {
    const filePathArr = await resolveInput(inputArr);

    for (let i = 0; i < filePathArr.length; ++i) {
      const filePath = filePathArr[i];
      console.log("processing file: " + filePath);

      const workbook = readWorkbook(filePath);

      const out: Record<
        string,
        // sheet
        Array<Record<string, unknown>>
      > = {};

      for (let j = 0; j < workbook.SheetNames.length; ++j) {
        const sheetName = workbook.SheetNames[j];
        if (!this.#validate(sheetName)) continue;

        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, {
          header: 1,
          blankrows: false,
          defval: null,
        });

        // empty sheet
        if (rows.length === 0) continue;

        console.log("sheet: " + sheetName);
        const headerRow = rows.splice(options.headerRow - 1, 2)[0] as string[];

        const sheetRows: Array<Record<string, unknown>> = [];

        for (let m = 0; m < rows.length; ++m) {
          const row = rows[m] as unknown[];
          const rowJson: Record<string, unknown> = {};

          for (let n = 0; n < row.length; ++n) {
            const cellValue = row[n];
            const headerCell = headerRow[n];
            if (!this.#validate(headerCell)) continue;
            rowJson[this.#getColumnKey(headerCell)] = this.#convertColumnType(
              cellValue,
              headerCell
            );
          }

          sheetRows.push(rowJson);
        }

        out[sheetName] = sheetRows;
      }

      let outObj: object = out;
      if (Object.keys(outObj).length === 1) {
        outObj = Object.values(outObj)[0];
      }

      this.#pushTask(
        this.#writeToFile(
          this.#getOutFilePath(filePath, options),
          JSON.stringify(outObj)
        )
      );

      console.log("process finished.");
    }

    await this.#waitTasks();
  }

  async #writeToFile(file_p: string, content: string) {
    const file = await Deno.open(file_p, {
      write: true,
      truncate: true,
      create: true,
    });
    await file.write(new TextEncoder().encode(content));
  }

  #getOutFileName(filePath: string) {
    const fileName = path.basename(filePath);

    const outFileName = fileName.substring(
      0,
      fileName.indexOf(path.extname(fileName))
    );
    return outFileName;
  }

  #getOutFilePath(file_p: string, opts: Options) {
    const outFileName = this.#getOutFileName(file_p) + "." + opts.format;

    if (!opts.outDir) {
      return path.join(path.dirname(file_p), outFileName);
    }

    const outDir = path.resolve(opts.outDir);
    ensureDirSync(outDir);
    return path.join(outDir, outFileName);
  }

  #getColumnKey(headerCell: string): string {
    return headerCell.trim().split("#")[0];
  }

  #convertColumnType(cellValue: unknown, headerCell: string) {
    if (!cellValue) return cellValue;

    const columnType = headerCell.trim().split("#")[1] as ColumnType;

    switch (columnType) {
      case "int":
      case "float":
        return Number(cellValue);
      case "bool":
        return Boolean(cellValue);
      case "[]":
        return (cellValue as string).split(",");
      case "int[]":
      case "float[]":
        return (cellValue as string).split(",").map((val) => Number(val));
      case "string":
      default:
        return String(cellValue);
    }
  }

  // éªŒè¯æ•°æ®æ˜¯å¦éœ€è¦è¢«å¯¼å‡ºï¼Œè¿”å›trueåˆ™éªŒè¯é€šè¿‡ï¼ŒfalseéªŒè¯å¤±è´¥å³æ•°æ®ä¸å¯¼å‡º
  #validate(name: string) {
    // console.log("validate: " + name + " type: " + typeof name);
    if (name.trim().startsWith("!")) return false;
    return true;
  }
}

const exportCommand = new ExportCommand();

export default exportCommand;
